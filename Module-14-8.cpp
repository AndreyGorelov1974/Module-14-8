/*8. Морской бой (дополнительное задание)
Требуется реализовать упрощённую игру в морской бой. Игровое поле размером 10 на 10 клеток. Участвуют два игрока.
В арсенале каждого из них 4 маленьких кораблика размером в одну клетку, 3 небольших корабля размером в две клетки,
2 средних корабля размером в три клетки и один большой корабль размером в четыре клетки.
Для простоты клетки поля пронумерованы по вертикали от 0 до 9 и по горизонтали от 0 до 9.
Мы не будем использовать классические наименования клеток, такие как B4, C6, а просто два индекса.
Вначале игроки по очереди расставляют корабли, начиная с самых маленьких и заканчивая большими.
Маленькие корабли в одну клетку расставляются с помощью указания одной клетки-точки на поле, к примеру 2,1.
Корабли размерностью от двух клеток и выше расставляются с помощью координат их начала и конца, к примеру: 0,1–0,3.
Корабли могут быть установлены только строго вертикально или горизонтально.
Установка корабля по диагонали недопустима, об этом тоже надо сообщить пользователю.
Если корабль не может быть размещён на заданных клетках из-за того, что он столкнётся с другим кораблём (окажется на его клетках) или выйдет за пределы поля,
то игроку должно быть сделано предупреждение, после которого он должен переставить корабль на новые валидные координаты.
В нашем упрощённом варианте игры мы не будем обсчитывать соприкосновения кораблей друг с другом, а потому корабли вполне можно будет размещать друг к другу вплотную,
борт к борту. После того как все корабли расставлены, начинается игра. Игроки по очереди атакуют друг друга, называя координаты выстрела.
После выстрела в консоль выводится информация о его результате: попал или мимо. Если выстрел успешен, клетка, на которой был корабль (или его фрагмент),
затирается и становится пустой. Игра заканчивается тогда, когда все корабли одной из сторон будут полностью уничтожены. Как только это произойдёт,
в консоль выводится информация с номером игрока, который победил.

Советы и рекомендации
Действия игроков практически одинаковые, их можно объединить в функции.

В программе достаточно иметь два поля, по одному на каждого игрока.

Лучше создать три отдельные функции: одну для размещения одного корабля, еще одну как обёртку над первой (она будет размещать все корабли), а третью для удара по координате. Также вам потребуются два глобальных массива для двух отдельных участков моря:

bool field_1[10][10];
bool field_2[10][10];*/

#include <iostream>
#include <string>

//функция получения координат, возвращает двузначное число,
//первая цифра - строка игрового поля
//вторая цифра - колонка игрового поля
int get_coordinates(void) {
	return 33;
}

//функция получения направления корабля при расстановке, возвращает cимвол
//r - направо
//d - вниз
int get_direction(void) {
	return 'r';
}

//функция отображения игрового поля
void display_play_field(char arr[][10]) {

	std::cout << " A B C D E F G H I J" << std::endl;
	for (int i = 0; i < 10; ++i) {
		std::cout << i;
		for (int j = 0; j < 10; ++j) {
			std::cout << arr[i][j] << " ";
		}
		std::cout << std::endl;
	}
	return;
}

//функция рассстановки кораблей на игровом поле
void set_ship_to_play_field(char arr[][10], int deck, std::string player_name) {
	system("cls");
	display_play_field(arr);
	std::cout << player_name << " enter coordinates begin ship: ";
	--deck;
	//инициализируем границы поля проверки соседних кораблей
	int leftBorder = 0;
	int rightBorder = 0;
	int topBorder = 0;
	int bottomBorder = 0;
	int line = 0;
	int column = 0;
	char direction = 'r';
	while (true) {
		int coordinates = get_coordinates();
		//получаем номер строки и столбца на игровом поле
		line = coordinates / 10;
		column = coordinates % 10;
		//если 1 палуба то направление кораля не нужно
		if (deck != 0) {
			direction = get_direction();
		}
		//если выходит за границы игрового поля предупреждаеми возвращаемся к вводу координат
		if ((direction == 'r' && (column + deck) > 9) || (direction == 'd' && (line + deck) > 9)) {
			std::cout << "It is impossible to put a ship in this place!" << std::endl;
		}
		else {
			//задаём границы поля проверки соседних кораблей при направлении корабля горизонтально
			if (direction == 'r') {
				topBorder = line - 1;
				bottomBorder = line + 1;
				leftBorder = column - 1;
				rightBorder = column + deck + 1;
			}
			//задаём границы поля проверки соседних кораблей при направлении корабля вертикально
			if (direction == 'd') {
				topBorder = line - 1;
				bottomBorder = line + deck + 1;
				leftBorder = column - 1;
				rightBorder = column + 1;
			}
			//корректируем границы если корабль расположен на краю
			if (column == 0) {
				leftBorder = 0;
			}
			if (column == 9) {
				rightBorder = 9;
			}
			if (line == 0) {
				topBorder = 0;
			}
			if (line == 9) {
				bottomBorder = 9;
			}
			bool correct = true;
			for (int i = topBorder; i <= bottomBorder; ++i) {
				for (int j = leftBorder; j <= rightBorder; ++j) {
					if (arr[i][j] != '~') {
						correct = false;
					}
				}
			}
			if (correct) {
				break;
			}
			else {
				std::cout << "It is impossible to put a ship in this place!" << std::endl;
			}
		}
	}
	for (int i = topBorder; i <= bottomBorder; ++i) {
		for (int j = leftBorder; j <= rightBorder; ++j) {
			arr[i][j] = '*';
		}
	}
	if (direction == 'r') {
		for (int i = column; i <= column + deck; ++i) {
			arr[line][i] = 'O';
		}
	}
	if (direction == 'd') {
		for (int i = line; i <= line + deck; ++i) {
			arr[i][column] = 'O';
		}
	}
	return;
}

int main() {
	//игровое поле первого игрока
	char play_Field_1[10][10] = {
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},
	{'~','~','~','~','~','~','~','~','~','~'},};
	//игровое поле второго игрока
	char play_Field_2[10][10]={
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},
	{'+','+','+','+','+','+','+','+','+','+'},};

	//флаг игрока который выйграл
	int winnerFlag = 0;

	std::cout << "Welcome to the Battleship game!" << std::endl;

	int numberShip = 4;
	int numberDeck = 1;

	//расстановка кораблей первого игрока
	//внешний цикл по количеству палуб
	for (int i = 1; i < 5; ++i) {
		//внутренний цикл по количеству кораблей
		for (int j = 5 - i; j > 0; --j) {
			set_ship_to_play_field(play_Field_1, i, "Player 1");
		}
	}

	//расстановка кораблей второго игрока
	for (int i = 1; i < 5; ++i) {
		for (int j = 5 - i; j > 0; --j) {
			set_ship_to_play_field(play_Field_1, i, "Player 2");
		}
	}



	//основной цикл, пока winnerFlag не станет 1 или 2
	while ((winnerFlag != 1) && (winnerFlag != 2)) {

		winnerFlag = 1;
	}
}